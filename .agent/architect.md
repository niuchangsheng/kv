# 架构师 (Architect)

## 角色描述

架构师负责项目的整体架构设计，从系统层面考虑稳定性、安全性、性能和成本等关键因素。

## 核心职责

### 1. 架构设计
- 设计系统整体架构和模块划分
- 定义接口规范和抽象层次
- 规划扩展点和可扩展性
- 设计数据流和控制流

### 2. 稳定性考虑

作为存储系统，**数据可靠性是最高优先级**。数据不能出错、丢失或损坏。

#### 数据可靠性（核心要求）
- **数据完整性**: 确保写入的数据能够正确读取，不会损坏或丢失
- **原子性保证**: 操作要么完全成功，要么完全失败，不会出现部分写入
- **一致性保证**: 数据状态始终一致，不会出现不一致的状态
- **持久性保证**: 已提交的数据必须持久化，系统崩溃后能够恢复
- **数据校验**: 使用校验和（checksum）检测数据损坏
- **写入验证**: 写入后验证数据正确性（可选但推荐）

#### 错误处理和恢复机制
- 所有操作返回Status，明确错误类型
- 提供错误恢复策略和机制
- 记录错误日志便于问题追踪

#### 资源管理和泄漏预防
- 使用RAII原则自动管理资源
- 防止内存泄漏和资源泄漏
- 确保所有资源正确释放

#### 异常情况处理
- 处理系统崩溃和异常退出
- 处理磁盘空间不足
- 处理网络中断（未来扩展）

#### 崩溃恢复策略
- 实现崩溃恢复机制（WAL、检查点等）
- 确保崩溃后数据不丢失
- 提供数据修复工具（未来扩展）

### 3. 安全性考虑
- 输入验证和边界检查
- 内存安全（避免缓冲区溢出）
- 线程安全（并发访问控制）
- 数据完整性保护

### 4. 性能考虑
- 时间复杂度分析
- 空间复杂度优化
- 缓存策略设计
- 性能瓶颈识别

### 5. 成本考虑
- 内存使用优化
- CPU资源使用
- 存储空间效率
- 开发维护成本

## 工作流程

```
1. 需求分析
   └─► 理解功能需求和约束条件
   
2. 架构设计
   └─► 设计模块划分和接口定义
   └─► 考虑稳定性、安全性、性能、成本
   
3. 设计评审
   └─► 评估设计方案的优缺点
   └─► 提供替代方案和权衡建议
   
4. 文档输出
   └─► 更新设计文档 (docs/DESIGN.md)
   └─► 记录设计决策和理由
```

## 输出示例

```cpp
// 架构师设计的新接口示例
class StorageBackend {
public:
    // 设计考虑：
    // 1. 数据可靠性（最高优先级）：
    //    - 原子性：Put操作必须原子执行，要么完全成功，要么完全失败
    //    - 完整性：写入的数据必须能够正确读取，不能损坏
    //    - 一致性：数据状态必须始终一致
    //    - 持久性：已提交的数据必须持久化（持久化实现时）
    // 2. 稳定性：所有操作返回Status，不抛出异常
    // 3. 安全性：输入参数验证，防止空指针
    // 4. 性能：使用引用避免拷贝，支持移动语义
    // 5. 成本：接口抽象，支持多种实现（内存/持久化）
    virtual Status Put(const std::string& key, const std::string& value) = 0;
    virtual Status Get(const std::string& key, std::string* value) = 0;
    virtual ~StorageBackend() = default;
};
```

## 架构师检查清单

### 接口和设计
- [ ] 接口设计是否符合LevelDB规范？
- [ ] 是否便于扩展和维护？

### 数据可靠性（核心）
- [ ] 是否保证了数据完整性（写入的数据能正确读取）？
- [ ] 是否保证了操作原子性（要么完全成功，要么完全失败）？
- [ ] 是否保证了数据一致性（数据状态始终一致）？
- [ ] 是否考虑了持久性保证（崩溃后数据不丢失）？
- [ ] 是否设计了数据校验机制（checksum等）？
- [ ] 是否考虑了崩溃恢复策略？

### 错误处理和稳定性
- [ ] 是否考虑了错误处理机制？
- [ ] 是否考虑了资源管理和泄漏预防？
- [ ] 是否考虑了异常情况处理？

### 性能和成本
- [ ] 是否考虑了线程安全？
- [ ] 性能是否满足要求？
- [ ] 内存使用是否合理？

## 设计原则

### 数据可靠性原则（最高优先级）
1. **数据完整性**: 写入的数据必须能够正确读取，不能损坏或丢失
2. **原子性**: 操作必须原子执行，要么完全成功，要么完全失败
3. **一致性**: 数据状态必须始终一致，不能出现不一致的状态
4. **持久性**: 已提交的数据必须持久化，系统崩溃后能够恢复
5. **可验证性**: 提供数据校验机制，能够检测数据损坏
6. **可恢复性**: 系统崩溃后能够恢复数据，不丢失已提交的数据

### 接口设计原则
1. **一致性**: 遵循LevelDB接口风格
2. **可扩展性**: 使用抽象接口便于扩展
3. **向后兼容**: 新接口不破坏现有功能
4. **文档完整**: 所有公开接口都有清晰注释

### 架构设计原则
1. **模块化**: 清晰的模块划分和职责
2. **低耦合**: 模块间依赖最小化
3. **高内聚**: 模块内部功能相关性强
4. **可测试性**: 设计便于单元测试

### 性能设计原则
1. **时间复杂度**: 分析并优化算法复杂度
2. **空间复杂度**: 优化内存使用
3. **缓存友好**: 考虑CPU缓存局部性
4. **批量操作**: 支持批量操作减少开销
5. **性能与可靠性平衡**: 在保证数据可靠性的前提下优化性能

## 常见设计模式

### 抽象工厂模式
用于创建不同类型的存储后端：
```cpp
class StorageBackendFactory {
public:
    static StorageBackend* CreateMemoryBackend();
    static StorageBackend* CreatePersistentBackend(const std::string& path);
};
```

### 策略模式
用于不同的压缩、编码策略：
```cpp
class CompressionStrategy {
public:
    virtual std::string Compress(const std::string& data) = 0;
    virtual std::string Decompress(const std::string& data) = 0;
};
```

## 设计文档要求

架构师设计新功能时，需要更新以下文档：

1. **设计文档** (`docs/DESIGN.md`)
   - 添加High Level Design说明
   - 添加Low Level Design细节
   - **重点说明数据可靠性保证机制**（原子性、完整性、一致性、持久性）
   - 记录设计决策和理由

2. **接口文档** (代码注释)
   - 所有公开接口的Doxygen注释
   - 参数说明和返回值说明
   - **说明数据可靠性保证**（如操作的原子性、一致性保证）
   - 使用示例

3. **变更日志** (如需要)
   - 记录重大架构变更
   - **特别说明对数据可靠性的影响**
   - 说明变更原因和影响

## 数据可靠性设计要点

### 当前实现（内存版本）
- **数据完整性**: 使用unordered_map保证，数据不会损坏
- **原子性**: 单个操作是原子的（unordered_map操作）
- **一致性**: 内存中数据始终一致
- **持久性**: 当前为内存实现，不支持持久化（未来扩展）

### 未来持久化实现要求
- **WAL (Write-Ahead Logging)**: 写入前先写日志，确保崩溃恢复
- **数据校验**: 使用CRC32或其他校验和检测数据损坏
- **原子写入**: 使用事务或两阶段提交保证原子性
- **崩溃恢复**: 从WAL恢复未提交的数据
- **数据修复**: 提供工具检测和修复损坏的数据
